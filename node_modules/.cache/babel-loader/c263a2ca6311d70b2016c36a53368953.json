{"ast":null,"code":"import _classCallCheck from \"C:/project/gojs-react-complex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/project/gojs-react-complex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"C:/project/gojs-react-complex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/project/gojs-react-complex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/project/gojs-react-complex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/project/gojs-react-complex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/*\r\n*  Copyright (C) 1998-2021 by Northwoods Software Corporation. All Rights Reserved.\r\n*/\n\n/*\r\n* This is an extension and not part of the main GoJS library.\r\n* Note that the API for this class may change with any version, even point releases.\r\n* If you intend to use an extension in production, you should copy the code to your own source directory.\r\n* Extensions can be found in the GoJS kit under the extensions or extensionsTS folders.\r\n* See the Extensions intro page (https://gojs.net/latest/intro/extensions.html) for more information.\r\n*/\nimport * as go from 'gojs';\n/**\r\n * The GuidedDraggingTool class makes guidelines visible as the parts are dragged around a diagram\r\n * when the selected part is nearly aligned with another part.\r\n *\r\n * If you want to experiment with this extension, try the <a href=\"../../extensionsTS/GuidedDragging.html\">Guided Dragging</a> sample.\r\n * @category Tool Extension\r\n */\n\nexport var GuidedDraggingTool = /*#__PURE__*/function (_go$DraggingTool) {\n  _inherits(GuidedDraggingTool, _go$DraggingTool);\n\n  var _super = _createSuper(GuidedDraggingTool);\n\n  // horizontal guidelines\n  // vertical guidelines\n  // properties that the programmer can modify\n\n  /**\r\n   * Constructs a GuidedDraggingTool and sets up the temporary guideline parts.\r\n   */\n  function GuidedDraggingTool() {\n    var _this;\n\n    _classCallCheck(this, GuidedDraggingTool);\n\n    _this = _super.call(this);\n    _this.guidelineHtop = void 0;\n    _this.guidelineHbottom = void 0;\n    _this.guidelineHcenter = void 0;\n    _this.guidelineVleft = void 0;\n    _this.guidelineVright = void 0;\n    _this.guidelineVcenter = void 0;\n    _this._guidelineSnapDistance = 6;\n    _this._isGuidelineEnabled = true;\n    _this._horizontalGuidelineColor = 'gray';\n    _this._verticalGuidelineColor = 'gray';\n    _this._centerGuidelineColor = 'gray';\n    _this._guidelineWidth = 1;\n    _this._searchDistance = 1000;\n    _this._isGuidelineSnapEnabled = true;\n    var partProperties = {\n      layerName: 'Tool',\n      isInDocumentBounds: false\n    };\n    var shapeProperties = {\n      stroke: 'gray',\n      isGeometryPositioned: true\n    };\n    var $ = go.GraphObject.make; // temporary parts for horizonal guidelines\n\n    _this.guidelineHtop = $(go.Part, partProperties, $(go.Shape, shapeProperties, {\n      geometryString: 'M0 0 100 0'\n    }));\n    _this.guidelineHbottom = $(go.Part, partProperties, $(go.Shape, shapeProperties, {\n      geometryString: 'M0 0 100 0'\n    }));\n    _this.guidelineHcenter = $(go.Part, partProperties, $(go.Shape, shapeProperties, {\n      geometryString: 'M0 0 100 0'\n    })); // temporary parts for vertical guidelines\n\n    _this.guidelineVleft = $(go.Part, partProperties, $(go.Shape, shapeProperties, {\n      geometryString: 'M0 0 0 100'\n    }));\n    _this.guidelineVright = $(go.Part, partProperties, $(go.Shape, shapeProperties, {\n      geometryString: 'M0 0 0 100'\n    }));\n    _this.guidelineVcenter = $(go.Part, partProperties, $(go.Shape, shapeProperties, {\n      geometryString: 'M0 0 0 100'\n    }));\n    return _this;\n  }\n  /**\r\n   * Gets or sets the margin of error for which guidelines show up.\r\n   *\r\n   * The default value is 6.\r\n   * Guidelines will show up when the aligned nods are ± 6px away from perfect alignment.\r\n   */\n\n\n  _createClass(GuidedDraggingTool, [{\n    key: \"guidelineSnapDistance\",\n    get: function get() {\n      return this._guidelineSnapDistance;\n    },\n    set: function set(val) {\n      if (typeof val !== 'number' || isNaN(val) || val < 0) throw new Error('new value for GuideddraggingTool.guidelineSnapDistance must be a non-negative number');\n\n      if (this._guidelineSnapDistance !== val) {\n        this._guidelineSnapDistance = val;\n      }\n    }\n    /**\r\n     * Gets or sets whether the guidelines are enabled or disable.\r\n     *\r\n     * The default value is true.\r\n     */\n\n  }, {\n    key: \"isGuidelineEnabled\",\n    get: function get() {\n      return this._isGuidelineEnabled;\n    },\n    set: function set(val) {\n      if (typeof val !== 'boolean') throw new Error('new value for GuidedDraggingTool.isGuidelineEnabled must be a boolean value.');\n\n      if (this._isGuidelineEnabled !== val) {\n        this._isGuidelineEnabled = val;\n      }\n    }\n    /**\r\n     * Gets or sets the color of horizontal guidelines.\r\n     *\r\n     * The default value is \"gray\".\r\n     */\n\n  }, {\n    key: \"horizontalGuidelineColor\",\n    get: function get() {\n      return this._horizontalGuidelineColor;\n    },\n    set: function set(val) {\n      if (this._horizontalGuidelineColor !== val) {\n        this._horizontalGuidelineColor = val;\n        this.guidelineHbottom.elements.first().stroke = this._horizontalGuidelineColor;\n        this.guidelineHtop.elements.first().stroke = this._horizontalGuidelineColor;\n      }\n    }\n    /**\r\n     * Gets or sets the color of vertical guidelines.\r\n     *\r\n     * The default value is \"gray\".\r\n     */\n\n  }, {\n    key: \"verticalGuidelineColor\",\n    get: function get() {\n      return this._verticalGuidelineColor;\n    },\n    set: function set(val) {\n      if (this._verticalGuidelineColor !== val) {\n        this._verticalGuidelineColor = val;\n        this.guidelineVleft.elements.first().stroke = this._verticalGuidelineColor;\n        this.guidelineVright.elements.first().stroke = this._verticalGuidelineColor;\n      }\n    }\n    /**\r\n     * Gets or sets the color of center guidelines.\r\n     *\r\n     * The default value is \"gray\".\r\n     */\n\n  }, {\n    key: \"centerGuidelineColor\",\n    get: function get() {\n      return this._centerGuidelineColor;\n    },\n    set: function set(val) {\n      if (this._centerGuidelineColor !== val) {\n        this._centerGuidelineColor = val;\n        this.guidelineVcenter.elements.first().stroke = this._centerGuidelineColor;\n        this.guidelineHcenter.elements.first().stroke = this._centerGuidelineColor;\n      }\n    }\n    /**\r\n     * Gets or sets the width guidelines.\r\n     *\r\n     * The default value is 1.\r\n     */\n\n  }, {\n    key: \"guidelineWidth\",\n    get: function get() {\n      return this._guidelineWidth;\n    },\n    set: function set(val) {\n      if (typeof val !== 'number' || isNaN(val) || val < 0) throw new Error('New value for GuidedDraggingTool.guidelineWidth must be a non-negative number.');\n\n      if (this._guidelineWidth !== val) {\n        this._guidelineWidth = val;\n        this.guidelineVcenter.elements.first().strokeWidth = val;\n        this.guidelineHcenter.elements.first().strokeWidth = val;\n        this.guidelineVleft.elements.first().strokeWidth = val;\n        this.guidelineVright.elements.first().strokeWidth = val;\n        this.guidelineHbottom.elements.first().strokeWidth = val;\n        this.guidelineHtop.elements.first().strokeWidth = val;\n      }\n    }\n    /**\r\n     * Gets or sets the distance around the selected part to search for aligned parts.\r\n     *\r\n     * The default value is 1000.\r\n     * Set this to Infinity if you want to search the entire diagram no matter how far away.\r\n     */\n\n  }, {\n    key: \"searchDistance\",\n    get: function get() {\n      return this._searchDistance;\n    },\n    set: function set(val) {\n      if (typeof val !== 'number' || isNaN(val) || val <= 0) throw new Error('new value for GuidedDraggingTool.searchDistance must be a positive number.');\n\n      if (this._searchDistance !== val) {\n        this._searchDistance = val;\n      }\n    }\n    /**\r\n     * Gets or sets whether snapping to guidelines is enabled.\r\n     *\r\n     * The default value is true.\r\n     */\n\n  }, {\n    key: \"isGuidelineSnapEnabled\",\n    get: function get() {\n      return this._isGuidelineSnapEnabled;\n    },\n    set: function set(val) {\n      if (typeof val !== 'boolean') throw new Error('new value for GuidedDraggingTool.isGuidelineSnapEnabled must be a boolean.');\n\n      if (this._isGuidelineSnapEnabled !== val) {\n        this._isGuidelineSnapEnabled = val;\n      }\n    }\n    /**\r\n     * Removes all of the guidelines from the grid.\r\n     */\n\n  }, {\n    key: \"clearGuidelines\",\n    value: function clearGuidelines() {\n      this.diagram.remove(this.guidelineHbottom);\n      this.diagram.remove(this.guidelineHcenter);\n      this.diagram.remove(this.guidelineHtop);\n      this.diagram.remove(this.guidelineVleft);\n      this.diagram.remove(this.guidelineVright);\n      this.diagram.remove(this.guidelineVcenter);\n    }\n    /**\r\n     * Calls the base method and removes the guidelines from the graph.\r\n     */\n\n  }, {\n    key: \"doDeactivate\",\n    value: function doDeactivate() {\n      _get(_getPrototypeOf(GuidedDraggingTool.prototype), \"doDeactivate\", this).call(this); // clear any guidelines when dragging is done\n\n\n      this.clearGuidelines();\n    }\n    /**\r\n     * Shows vertical and horizontal guidelines for the dragged part.\r\n     */\n\n  }, {\n    key: \"doDragOver\",\n    value: function doDragOver(pt, obj) {\n      // clear all existing guidelines in case either show... method decides to show a guideline\n      this.clearGuidelines(); // gets the selected part\n\n      var draggingParts = this.copiedParts || this.draggedParts;\n      if (draggingParts === null) return;\n      var partItr = draggingParts.iterator;\n\n      if (partItr.next()) {\n        var part = partItr.key;\n        this.showHorizontalMatches(part, this.isGuidelineEnabled, false);\n        this.showVerticalMatches(part, this.isGuidelineEnabled, false);\n      }\n    }\n    /**\r\n     * On a mouse-up, snaps the selected part to the nearest guideline.\r\n     * If not snapping, the part remains at its position.\r\n     */\n\n  }, {\n    key: \"doDropOnto\",\n    value: function doDropOnto(pt, obj) {\n      this.clearGuidelines(); // gets the selected (perhaps copied) Part\n\n      var draggingParts = this.copiedParts || this.draggedParts;\n      if (draggingParts === null) return;\n      var partItr = draggingParts.iterator;\n\n      if (partItr.next()) {\n        var part = partItr.key; // snaps only when the mouse is released without shift modifier\n\n        var e = this.diagram.lastInput;\n        var snap = this.isGuidelineSnapEnabled && !e.shift;\n        this.showHorizontalMatches(part, false, snap); // false means don't show guidelines\n\n        this.showVerticalMatches(part, false, snap);\n      }\n    }\n    /**\r\n     * When nodes are shifted due to being guided upon a drop, make sure all connected link routes are invalidated,\r\n     * since the node is likely to have moved a different amount than all its connected links in the regular\r\n     * operation of the DraggingTool.\r\n     */\n\n  }, {\n    key: \"invalidateLinks\",\n    value: function invalidateLinks(node) {\n      if (node instanceof go.Node) node.invalidateConnectedLinks();\n    }\n    /**\r\n     * This finds parts that are aligned near the selected part along horizontal lines. It compares the selected\r\n     * part to all parts within a rectangle approximately twice the {@link #searchDistance} wide.\r\n     * The guidelines appear when a part is aligned within a margin-of-error equal to {@link #guidelineSnapDistance}.\r\n     * @param {Node} part\r\n     * @param {boolean} guideline if true, show guideline\r\n     * @param {boolean} snap if true, snap the part to where the guideline would be\r\n     */\n\n  }, {\n    key: \"showHorizontalMatches\",\n    value: function showHorizontalMatches(part, guideline, snap) {\n      var objBounds = part.locationObject.getDocumentBounds();\n      var p0 = objBounds.y;\n      var p1 = objBounds.y + objBounds.height / 2;\n      var p2 = objBounds.y + objBounds.height;\n      var marginOfError = this.guidelineSnapDistance;\n      var distance = this.searchDistance; // compares with parts within narrow vertical area\n\n      var area = objBounds.copy();\n      area.inflate(distance, marginOfError + 1);\n      var otherObjs = this.diagram.findObjectsIn(area, function (obj) {\n        return obj.part;\n      }, function (p) {\n        return p instanceof go.Part && !p.isSelected && !(p instanceof go.Link) && p.isTopLevel && p.layer !== null && !p.layer.isTemporary;\n      }, true);\n      var bestDiff = marginOfError;\n      var bestObj = null; // TS 2.6 won't let this be go.Part | null\n\n      var bestSpot = go.Spot.Default;\n      var bestOtherSpot = go.Spot.Default; // horizontal line -- comparing y-values\n\n      otherObjs.each(function (other) {\n        if (other === part) return; // ignore itself\n\n        var otherBounds = other.locationObject.getDocumentBounds();\n        var q0 = otherBounds.y;\n        var q1 = otherBounds.y + otherBounds.height / 2;\n        var q2 = otherBounds.y + otherBounds.height; // compare center with center of OTHER part\n\n        if (Math.abs(p1 - q1) < bestDiff) {\n          bestDiff = Math.abs(p1 - q1);\n          bestObj = other;\n          bestSpot = go.Spot.Center;\n          bestOtherSpot = go.Spot.Center;\n        } // compare top side with top and bottom sides of OTHER part\n\n\n        if (Math.abs(p0 - q0) < bestDiff) {\n          bestDiff = Math.abs(p0 - q0);\n          bestObj = other;\n          bestSpot = go.Spot.Top;\n          bestOtherSpot = go.Spot.Top;\n        } else if (Math.abs(p0 - q2) < bestDiff) {\n          bestDiff = Math.abs(p0 - q2);\n          bestObj = other;\n          bestSpot = go.Spot.Top;\n          bestOtherSpot = go.Spot.Bottom;\n        } // compare bottom side with top and bottom sides of OTHER part\n\n\n        if (Math.abs(p2 - q0) < bestDiff) {\n          bestDiff = Math.abs(p2 - q0);\n          bestObj = other;\n          bestSpot = go.Spot.Bottom;\n          bestOtherSpot = go.Spot.Top;\n        } else if (Math.abs(p2 - q2) < bestDiff) {\n          bestDiff = Math.abs(p2 - q2);\n          bestObj = other;\n          bestSpot = go.Spot.Bottom;\n          bestOtherSpot = go.Spot.Bottom;\n        }\n      });\n\n      if (bestObj !== null) {\n        var offsetX = objBounds.x - part.actualBounds.x;\n        var offsetY = objBounds.y - part.actualBounds.y;\n        var bestBounds = bestObj.locationObject.getDocumentBounds(); // line extends from x0 to x2\n\n        var x0 = Math.min(objBounds.x, bestBounds.x) - 10;\n        var x2 = Math.max(objBounds.x + objBounds.width, bestBounds.x + bestBounds.width) + 10; // find bestObj's desired Y\n\n        var bestPoint = new go.Point().setRectSpot(bestBounds, bestOtherSpot);\n\n        if (bestSpot === go.Spot.Center) {\n          if (snap) {\n            // call Part.move in order to automatically move member Parts of Groups\n            part.move(new go.Point(objBounds.x - offsetX, bestPoint.y - objBounds.height / 2 - offsetY));\n            this.invalidateLinks(part);\n          }\n\n          if (guideline) {\n            this.guidelineHcenter.position = new go.Point(x0, bestPoint.y);\n            this.guidelineHcenter.elt(0).width = x2 - x0;\n            this.diagram.add(this.guidelineHcenter);\n          }\n        } else if (bestSpot === go.Spot.Top) {\n          if (snap) {\n            part.move(new go.Point(objBounds.x - offsetX, bestPoint.y - offsetY));\n            this.invalidateLinks(part);\n          }\n\n          if (guideline) {\n            this.guidelineHtop.position = new go.Point(x0, bestPoint.y);\n            this.guidelineHtop.elt(0).width = x2 - x0;\n            this.diagram.add(this.guidelineHtop);\n          }\n        } else if (bestSpot === go.Spot.Bottom) {\n          if (snap) {\n            part.move(new go.Point(objBounds.x - offsetX, bestPoint.y - objBounds.height - offsetY));\n            this.invalidateLinks(part);\n          }\n\n          if (guideline) {\n            this.guidelineHbottom.position = new go.Point(x0, bestPoint.y);\n            this.guidelineHbottom.elt(0).width = x2 - x0;\n            this.diagram.add(this.guidelineHbottom);\n          }\n        }\n      }\n    }\n    /**\r\n     * This finds parts that are aligned near the selected part along vertical lines. It compares the selected\r\n     * part to all parts within a rectangle approximately twice the {@link #searchDistance} tall.\r\n     * The guidelines appear when a part is aligned within a margin-of-error equal to {@link #guidelineSnapDistance}.\r\n     * @param {Part} part\r\n     * @param {boolean} guideline if true, show guideline\r\n     * @param {boolean} snap if true, don't show guidelines but just snap the part to where the guideline would be\r\n     */\n\n  }, {\n    key: \"showVerticalMatches\",\n    value: function showVerticalMatches(part, guideline, snap) {\n      var objBounds = part.locationObject.getDocumentBounds();\n      var p0 = objBounds.x;\n      var p1 = objBounds.x + objBounds.width / 2;\n      var p2 = objBounds.x + objBounds.width;\n      var marginOfError = this.guidelineSnapDistance;\n      var distance = this.searchDistance; // compares with parts within narrow vertical area\n\n      var area = objBounds.copy();\n      area.inflate(marginOfError + 1, distance);\n      var otherObjs = this.diagram.findObjectsIn(area, function (obj) {\n        return obj.part;\n      }, function (p) {\n        return p instanceof go.Part && !p.isSelected && !(p instanceof go.Link) && p.isTopLevel && p.layer !== null && !p.layer.isTemporary;\n      }, true);\n      var bestDiff = marginOfError;\n      var bestObj = null; // TS 2.6 won't let this be go.Part | null\n\n      var bestSpot = go.Spot.Default;\n      var bestOtherSpot = go.Spot.Default; // vertical line -- comparing x-values\n\n      otherObjs.each(function (other) {\n        if (other === part) return; // ignore itself\n\n        var otherBounds = other.locationObject.getDocumentBounds();\n        var q0 = otherBounds.x;\n        var q1 = otherBounds.x + otherBounds.width / 2;\n        var q2 = otherBounds.x + otherBounds.width; // compare center with center of OTHER part\n\n        if (Math.abs(p1 - q1) < bestDiff) {\n          bestDiff = Math.abs(p1 - q1);\n          bestObj = other;\n          bestSpot = go.Spot.Center;\n          bestOtherSpot = go.Spot.Center;\n        } // compare left side with left and right sides of OTHER part\n\n\n        if (Math.abs(p0 - q0) < bestDiff) {\n          bestDiff = Math.abs(p0 - q0);\n          bestObj = other;\n          bestSpot = go.Spot.Left;\n          bestOtherSpot = go.Spot.Left;\n        } else if (Math.abs(p0 - q2) < bestDiff) {\n          bestDiff = Math.abs(p0 - q2);\n          bestObj = other;\n          bestSpot = go.Spot.Left;\n          bestOtherSpot = go.Spot.Right;\n        } // compare right side with left and right sides of OTHER part\n\n\n        if (Math.abs(p2 - q0) < bestDiff) {\n          bestDiff = Math.abs(p2 - q0);\n          bestObj = other;\n          bestSpot = go.Spot.Right;\n          bestOtherSpot = go.Spot.Left;\n        } else if (Math.abs(p2 - q2) < bestDiff) {\n          bestDiff = Math.abs(p2 - q2);\n          bestObj = other;\n          bestSpot = go.Spot.Right;\n          bestOtherSpot = go.Spot.Right;\n        }\n      });\n\n      if (bestObj !== null) {\n        var offsetX = objBounds.x - part.actualBounds.x;\n        var offsetY = objBounds.y - part.actualBounds.y;\n        var bestBounds = bestObj.locationObject.getDocumentBounds(); // line extends from y0 to y2\n\n        var y0 = Math.min(objBounds.y, bestBounds.y) - 10;\n        var y2 = Math.max(objBounds.y + objBounds.height, bestBounds.y + bestBounds.height) + 10; // find bestObj's desired X\n\n        var bestPoint = new go.Point().setRectSpot(bestBounds, bestOtherSpot);\n\n        if (bestSpot === go.Spot.Center) {\n          if (snap) {\n            // call Part.move in order to automatically move member Parts of Groups\n            part.move(new go.Point(bestPoint.x - objBounds.width / 2 - offsetX, objBounds.y - offsetY));\n            this.invalidateLinks(part);\n          }\n\n          if (guideline) {\n            this.guidelineVcenter.position = new go.Point(bestPoint.x, y0);\n            this.guidelineVcenter.elt(0).height = y2 - y0;\n            this.diagram.add(this.guidelineVcenter);\n          }\n        } else if (bestSpot === go.Spot.Left) {\n          if (snap) {\n            part.move(new go.Point(bestPoint.x - offsetX, objBounds.y - offsetY));\n            this.invalidateLinks(part);\n          }\n\n          if (guideline) {\n            this.guidelineVleft.position = new go.Point(bestPoint.x, y0);\n            this.guidelineVleft.elt(0).height = y2 - y0;\n            this.diagram.add(this.guidelineVleft);\n          }\n        } else if (bestSpot === go.Spot.Right) {\n          if (snap) {\n            part.move(new go.Point(bestPoint.x - objBounds.width - offsetX, objBounds.y - offsetY));\n            this.invalidateLinks(part);\n          }\n\n          if (guideline) {\n            this.guidelineVright.position = new go.Point(bestPoint.x, y0);\n            this.guidelineVright.elt(0).height = y2 - y0;\n            this.diagram.add(this.guidelineVright);\n          }\n        }\n      }\n    }\n  }]);\n\n  return GuidedDraggingTool;\n}(go.DraggingTool);","map":{"version":3,"sources":["C:/project/gojs-react-complex/src/GuidedDraggingTool.ts"],"names":["go","GuidedDraggingTool","guidelineHtop","guidelineHbottom","guidelineHcenter","guidelineVleft","guidelineVright","guidelineVcenter","_guidelineSnapDistance","_isGuidelineEnabled","_horizontalGuidelineColor","_verticalGuidelineColor","_centerGuidelineColor","_guidelineWidth","_searchDistance","_isGuidelineSnapEnabled","partProperties","layerName","isInDocumentBounds","shapeProperties","stroke","isGeometryPositioned","$","GraphObject","make","Part","Shape","geometryString","val","isNaN","Error","elements","first","strokeWidth","diagram","remove","clearGuidelines","pt","obj","draggingParts","copiedParts","draggedParts","partItr","iterator","next","part","key","showHorizontalMatches","isGuidelineEnabled","showVerticalMatches","e","lastInput","snap","isGuidelineSnapEnabled","shift","node","Node","invalidateConnectedLinks","guideline","objBounds","locationObject","getDocumentBounds","p0","y","p1","height","p2","marginOfError","guidelineSnapDistance","distance","searchDistance","area","copy","inflate","otherObjs","findObjectsIn","p","isSelected","Link","isTopLevel","layer","isTemporary","bestDiff","bestObj","bestSpot","Spot","Default","bestOtherSpot","each","other","otherBounds","q0","q1","q2","Math","abs","Center","Top","Bottom","offsetX","x","actualBounds","offsetY","bestBounds","x0","min","x2","max","width","bestPoint","Point","setRectSpot","move","invalidateLinks","position","elt","add","Left","Right","y0","y2","DraggingTool"],"mappings":"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","sourcesContent":["/*\r\n*  Copyright (C) 1998-2021 by Northwoods Software Corporation. All Rights Reserved.\r\n*/\r\n\r\n/*\r\n* This is an extension and not part of the main GoJS library.\r\n* Note that the API for this class may change with any version, even point releases.\r\n* If you intend to use an extension in production, you should copy the code to your own source directory.\r\n* Extensions can be found in the GoJS kit under the extensions or extensionsTS folders.\r\n* See the Extensions intro page (https://gojs.net/latest/intro/extensions.html) for more information.\r\n*/\r\nimport * as go from 'gojs';\r\n\r\n/**\r\n * The GuidedDraggingTool class makes guidelines visible as the parts are dragged around a diagram\r\n * when the selected part is nearly aligned with another part.\r\n *\r\n * If you want to experiment with this extension, try the <a href=\"../../extensionsTS/GuidedDragging.html\">Guided Dragging</a> sample.\r\n * @category Tool Extension\r\n */\r\nexport class GuidedDraggingTool extends go.DraggingTool {\r\n  // horizontal guidelines\r\n  private guidelineHtop: go.Part;\r\n  private guidelineHbottom: go.Part;\r\n  private guidelineHcenter: go.Part;\r\n  // vertical guidelines\r\n  private guidelineVleft: go.Part;\r\n  private guidelineVright: go.Part;\r\n  private guidelineVcenter: go.Part;\r\n\r\n  // properties that the programmer can modify\r\n  private _guidelineSnapDistance: number = 6;\r\n  private _isGuidelineEnabled: boolean = true;\r\n  private _horizontalGuidelineColor: string = 'gray';\r\n  private _verticalGuidelineColor: string = 'gray';\r\n  private _centerGuidelineColor: string = 'gray';\r\n  private _guidelineWidth: number = 1;\r\n  private _searchDistance: number = 1000;\r\n  private _isGuidelineSnapEnabled: boolean = true;\r\n\r\n  /**\r\n   * Constructs a GuidedDraggingTool and sets up the temporary guideline parts.\r\n   */\r\n  constructor() {\r\n    super();\r\n\r\n    const partProperties = { layerName: 'Tool', isInDocumentBounds: false };\r\n    const shapeProperties = { stroke: 'gray', isGeometryPositioned: true };\r\n\r\n    const $ = go.GraphObject.make;\r\n    // temporary parts for horizonal guidelines\r\n    this.guidelineHtop =\r\n      $(go.Part, partProperties,\r\n        $(go.Shape, shapeProperties, { geometryString: 'M0 0 100 0' }));\r\n    this.guidelineHbottom =\r\n      $(go.Part, partProperties,\r\n        $(go.Shape, shapeProperties, { geometryString: 'M0 0 100 0' }));\r\n    this.guidelineHcenter =\r\n      $(go.Part, partProperties,\r\n        $(go.Shape, shapeProperties, { geometryString: 'M0 0 100 0' }));\r\n    // temporary parts for vertical guidelines\r\n    this.guidelineVleft =\r\n      $(go.Part, partProperties,\r\n        $(go.Shape, shapeProperties, { geometryString: 'M0 0 0 100' }));\r\n    this.guidelineVright =\r\n      $(go.Part, partProperties,\r\n        $(go.Shape, shapeProperties, { geometryString: 'M0 0 0 100' }));\r\n    this.guidelineVcenter =\r\n      $(go.Part, partProperties,\r\n        $(go.Shape, shapeProperties, { geometryString: 'M0 0 0 100' }));\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the margin of error for which guidelines show up.\r\n   *\r\n   * The default value is 6.\r\n   * Guidelines will show up when the aligned nods are ± 6px away from perfect alignment.\r\n   */\r\n  get guidelineSnapDistance(): number { return this._guidelineSnapDistance; }\r\n  set guidelineSnapDistance(val: number) {\r\n    if (typeof val !== 'number' || isNaN(val) || val < 0) throw new Error('new value for GuideddraggingTool.guidelineSnapDistance must be a non-negative number');\r\n    if (this._guidelineSnapDistance !== val) {\r\n      this._guidelineSnapDistance = val;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or sets whether the guidelines are enabled or disable.\r\n   *\r\n   * The default value is true.\r\n   */\r\n  get isGuidelineEnabled(): boolean { return this._isGuidelineEnabled; }\r\n  set isGuidelineEnabled(val: boolean) {\r\n    if (typeof val !== 'boolean') throw new Error('new value for GuidedDraggingTool.isGuidelineEnabled must be a boolean value.');\r\n    if (this._isGuidelineEnabled !== val) {\r\n      this._isGuidelineEnabled = val;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the color of horizontal guidelines.\r\n   *\r\n   * The default value is \"gray\".\r\n   */\r\n  get horizontalGuidelineColor(): string { return this._horizontalGuidelineColor; }\r\n  set horizontalGuidelineColor(val: string) {\r\n    if (this._horizontalGuidelineColor !== val) {\r\n      this._horizontalGuidelineColor = val;\r\n      (this.guidelineHbottom.elements.first() as go.Shape).stroke = this._horizontalGuidelineColor;\r\n      (this.guidelineHtop.elements.first() as go.Shape).stroke = this._horizontalGuidelineColor;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the color of vertical guidelines.\r\n   *\r\n   * The default value is \"gray\".\r\n   */\r\n  get verticalGuidelineColor(): string { return this._verticalGuidelineColor; }\r\n  set verticalGuidelineColor(val: string) {\r\n    if (this._verticalGuidelineColor !== val) {\r\n      this._verticalGuidelineColor = val;\r\n      (this.guidelineVleft.elements.first() as go.Shape).stroke = this._verticalGuidelineColor;\r\n      (this.guidelineVright.elements.first() as go.Shape).stroke = this._verticalGuidelineColor;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the color of center guidelines.\r\n   *\r\n   * The default value is \"gray\".\r\n   */\r\n  get centerGuidelineColor(): string { return this._centerGuidelineColor; }\r\n  set centerGuidelineColor(val: string) {\r\n    if (this._centerGuidelineColor !== val) {\r\n      this._centerGuidelineColor = val;\r\n      (this.guidelineVcenter.elements.first() as go.Shape).stroke = this._centerGuidelineColor;\r\n      (this.guidelineHcenter.elements.first() as go.Shape).stroke = this._centerGuidelineColor;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the width guidelines.\r\n   *\r\n   * The default value is 1.\r\n   */\r\n  get guidelineWidth(): number { return this._guidelineWidth; }\r\n  set guidelineWidth(val: number) {\r\n    if (typeof val !== 'number' || isNaN(val) || val < 0) throw new Error('New value for GuidedDraggingTool.guidelineWidth must be a non-negative number.');\r\n    if (this._guidelineWidth !== val) {\r\n      this._guidelineWidth = val;\r\n      (this.guidelineVcenter.elements.first() as go.Shape).strokeWidth = val;\r\n      (this.guidelineHcenter.elements.first() as go.Shape).strokeWidth = val;\r\n      (this.guidelineVleft.elements.first() as go.Shape).strokeWidth = val;\r\n      (this.guidelineVright.elements.first() as go.Shape).strokeWidth = val;\r\n      (this.guidelineHbottom.elements.first() as go.Shape).strokeWidth = val;\r\n      (this.guidelineHtop.elements.first() as go.Shape).strokeWidth = val;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the distance around the selected part to search for aligned parts.\r\n   *\r\n   * The default value is 1000.\r\n   * Set this to Infinity if you want to search the entire diagram no matter how far away.\r\n   */\r\n  get searchDistance(): number { return this._searchDistance; }\r\n  set searchDistance(val: number) {\r\n    if (typeof val !== 'number' || isNaN(val) || val <= 0) throw new Error('new value for GuidedDraggingTool.searchDistance must be a positive number.');\r\n    if (this._searchDistance !== val) {\r\n      this._searchDistance = val;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or sets whether snapping to guidelines is enabled.\r\n   *\r\n   * The default value is true.\r\n   */\r\n  get isGuidelineSnapEnabled(): boolean { return this._isGuidelineSnapEnabled; }\r\n  set isGuidelineSnapEnabled(val: boolean) {\r\n    if (typeof val !== 'boolean') throw new Error('new value for GuidedDraggingTool.isGuidelineSnapEnabled must be a boolean.');\r\n    if (this._isGuidelineSnapEnabled !== val) {\r\n      this._isGuidelineSnapEnabled = val;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all of the guidelines from the grid.\r\n   */\r\n  public clearGuidelines(): void {\r\n    this.diagram.remove(this.guidelineHbottom);\r\n    this.diagram.remove(this.guidelineHcenter);\r\n    this.diagram.remove(this.guidelineHtop);\r\n    this.diagram.remove(this.guidelineVleft);\r\n    this.diagram.remove(this.guidelineVright);\r\n    this.diagram.remove(this.guidelineVcenter);\r\n  }\r\n\r\n  /**\r\n   * Calls the base method and removes the guidelines from the graph.\r\n   */\r\n  public doDeactivate(): void {\r\n    super.doDeactivate();\r\n    // clear any guidelines when dragging is done\r\n    this.clearGuidelines();\r\n  }\r\n\r\n  /**\r\n   * Shows vertical and horizontal guidelines for the dragged part.\r\n   */\r\n  public doDragOver(pt: go.Point, obj: go.GraphObject): void {\r\n    // clear all existing guidelines in case either show... method decides to show a guideline\r\n    this.clearGuidelines();\r\n\r\n    // gets the selected part\r\n    const draggingParts = this.copiedParts || this.draggedParts;\r\n    if (draggingParts === null) return;\r\n    const partItr = draggingParts.iterator;\r\n    if (partItr.next()) {\r\n      const part = partItr.key;\r\n\r\n      this.showHorizontalMatches(part, this.isGuidelineEnabled, false);\r\n      this.showVerticalMatches(part, this.isGuidelineEnabled, false);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * On a mouse-up, snaps the selected part to the nearest guideline.\r\n   * If not snapping, the part remains at its position.\r\n   */\r\n  public doDropOnto(pt: go.Point, obj: go.GraphObject): void {\r\n    this.clearGuidelines();\r\n\r\n    // gets the selected (perhaps copied) Part\r\n    const draggingParts = this.copiedParts || this.draggedParts;\r\n    if (draggingParts === null) return;\r\n    const partItr = draggingParts.iterator;\r\n    if (partItr.next()) {\r\n      const part = partItr.key;\r\n\r\n      // snaps only when the mouse is released without shift modifier\r\n      const e = this.diagram.lastInput;\r\n      const snap = this.isGuidelineSnapEnabled && !e.shift;\r\n\r\n      this.showHorizontalMatches(part, false, snap);  // false means don't show guidelines\r\n      this.showVerticalMatches(part, false, snap);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * When nodes are shifted due to being guided upon a drop, make sure all connected link routes are invalidated,\r\n   * since the node is likely to have moved a different amount than all its connected links in the regular\r\n   * operation of the DraggingTool.\r\n   */\r\n  public invalidateLinks(node: go.Part): void {\r\n    if (node instanceof go.Node) node.invalidateConnectedLinks();\r\n  }\r\n\r\n  /**\r\n   * This finds parts that are aligned near the selected part along horizontal lines. It compares the selected\r\n   * part to all parts within a rectangle approximately twice the {@link #searchDistance} wide.\r\n   * The guidelines appear when a part is aligned within a margin-of-error equal to {@link #guidelineSnapDistance}.\r\n   * @param {Node} part\r\n   * @param {boolean} guideline if true, show guideline\r\n   * @param {boolean} snap if true, snap the part to where the guideline would be\r\n   */\r\n  public showHorizontalMatches(part: go.Part, guideline: boolean, snap: boolean): void {\r\n    const objBounds = part.locationObject.getDocumentBounds();\r\n    const p0 = objBounds.y;\r\n    const p1 = objBounds.y + objBounds.height / 2;\r\n    const p2 = objBounds.y + objBounds.height;\r\n\r\n    const marginOfError = this.guidelineSnapDistance;\r\n    const distance = this.searchDistance;\r\n    // compares with parts within narrow vertical area\r\n    const area = objBounds.copy();\r\n    area.inflate(distance, marginOfError + 1);\r\n    const otherObjs = this.diagram.findObjectsIn(area,\r\n      (obj) => obj.part as go.Part,\r\n      (p) => p instanceof go.Part && !p.isSelected && !(p instanceof go.Link) && p.isTopLevel && p.layer !== null && !p.layer.isTemporary,\r\n      true) as go.Set<go.Part>;\r\n\r\n    let bestDiff: number = marginOfError;\r\n    let bestObj: any = null; // TS 2.6 won't let this be go.Part | null\r\n    let bestSpot: go.Spot = go.Spot.Default;\r\n    let bestOtherSpot: go.Spot = go.Spot.Default;\r\n    // horizontal line -- comparing y-values\r\n    otherObjs.each((other) => {\r\n      if (other === part) return; // ignore itself\r\n\r\n      const otherBounds = other.locationObject.getDocumentBounds();\r\n      const q0 = otherBounds.y;\r\n      const q1 = otherBounds.y + otherBounds.height / 2;\r\n      const q2 = otherBounds.y + otherBounds.height;\r\n\r\n      // compare center with center of OTHER part\r\n      if (Math.abs(p1 - q1) < bestDiff) {\r\n        bestDiff = Math.abs(p1 - q1);\r\n        bestObj = other;\r\n        bestSpot = go.Spot.Center;\r\n        bestOtherSpot = go.Spot.Center;\r\n      }\r\n      // compare top side with top and bottom sides of OTHER part\r\n      if (Math.abs(p0 - q0) < bestDiff) {\r\n        bestDiff = Math.abs(p0 - q0);\r\n        bestObj = other;\r\n        bestSpot = go.Spot.Top;\r\n        bestOtherSpot = go.Spot.Top;\r\n      } else if (Math.abs(p0 - q2) < bestDiff) {\r\n        bestDiff = Math.abs(p0 - q2);\r\n        bestObj = other;\r\n        bestSpot = go.Spot.Top;\r\n        bestOtherSpot = go.Spot.Bottom;\r\n      }\r\n      // compare bottom side with top and bottom sides of OTHER part\r\n      if (Math.abs(p2 - q0) < bestDiff) {\r\n        bestDiff = Math.abs(p2 - q0);\r\n        bestObj = other;\r\n        bestSpot = go.Spot.Bottom;\r\n        bestOtherSpot = go.Spot.Top;\r\n      } else if (Math.abs(p2 - q2) < bestDiff) {\r\n        bestDiff = Math.abs(p2 - q2);\r\n        bestObj = other;\r\n        bestSpot = go.Spot.Bottom;\r\n        bestOtherSpot = go.Spot.Bottom;\r\n      }\r\n    });\r\n\r\n    if (bestObj !== null) {\r\n      const offsetX = objBounds.x - part.actualBounds.x;\r\n      const offsetY = objBounds.y - part.actualBounds.y;\r\n      const bestBounds = bestObj.locationObject.getDocumentBounds();\r\n      // line extends from x0 to x2\r\n      const x0 = Math.min(objBounds.x, bestBounds.x) - 10;\r\n      const x2 = Math.max(objBounds.x + objBounds.width, bestBounds.x + bestBounds.width) + 10;\r\n      // find bestObj's desired Y\r\n      const bestPoint = new go.Point().setRectSpot(bestBounds, bestOtherSpot);\r\n      if (bestSpot === go.Spot.Center) {\r\n        if (snap) {\r\n          // call Part.move in order to automatically move member Parts of Groups\r\n          part.move(new go.Point(objBounds.x - offsetX, bestPoint.y - objBounds.height / 2 - offsetY));\r\n          this.invalidateLinks(part);\r\n        }\r\n        if (guideline) {\r\n          this.guidelineHcenter.position = new go.Point(x0, bestPoint.y);\r\n          this.guidelineHcenter.elt(0).width = x2 - x0;\r\n          this.diagram.add(this.guidelineHcenter);\r\n        }\r\n      } else if (bestSpot === go.Spot.Top) {\r\n        if (snap) {\r\n          part.move(new go.Point(objBounds.x - offsetX, bestPoint.y - offsetY));\r\n          this.invalidateLinks(part);\r\n        }\r\n        if (guideline) {\r\n          this.guidelineHtop.position = new go.Point(x0, bestPoint.y);\r\n          this.guidelineHtop.elt(0).width = x2 - x0;\r\n          this.diagram.add(this.guidelineHtop);\r\n        }\r\n      } else if (bestSpot === go.Spot.Bottom) {\r\n        if (snap) {\r\n          part.move(new go.Point(objBounds.x - offsetX, bestPoint.y - objBounds.height - offsetY));\r\n          this.invalidateLinks(part);\r\n        }\r\n        if (guideline) {\r\n          this.guidelineHbottom.position = new go.Point(x0, bestPoint.y);\r\n          this.guidelineHbottom.elt(0).width = x2 - x0;\r\n          this.diagram.add(this.guidelineHbottom);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This finds parts that are aligned near the selected part along vertical lines. It compares the selected\r\n   * part to all parts within a rectangle approximately twice the {@link #searchDistance} tall.\r\n   * The guidelines appear when a part is aligned within a margin-of-error equal to {@link #guidelineSnapDistance}.\r\n   * @param {Part} part\r\n   * @param {boolean} guideline if true, show guideline\r\n   * @param {boolean} snap if true, don't show guidelines but just snap the part to where the guideline would be\r\n   */\r\n  public showVerticalMatches(part: go.Part, guideline: boolean, snap: boolean): void {\r\n    const objBounds = part.locationObject.getDocumentBounds();\r\n    const p0 = objBounds.x;\r\n    const p1 = objBounds.x + objBounds.width / 2;\r\n    const p2 = objBounds.x + objBounds.width;\r\n\r\n    const marginOfError = this.guidelineSnapDistance;\r\n    const distance = this.searchDistance;\r\n    // compares with parts within narrow vertical area\r\n    const area = objBounds.copy();\r\n    area.inflate(marginOfError + 1, distance);\r\n    const otherObjs = this.diagram.findObjectsIn(area,\r\n      (obj) => obj.part as go.Part,\r\n      (p) => p instanceof go.Part && !p.isSelected && !(p instanceof go.Link) && p.isTopLevel && p.layer !== null && !p.layer.isTemporary,\r\n      true) as go.Set<go.Part>;\r\n\r\n    let bestDiff: number = marginOfError;\r\n    let bestObj: any = null;  // TS 2.6 won't let this be go.Part | null\r\n    let bestSpot: go.Spot = go.Spot.Default;\r\n    let bestOtherSpot: go.Spot = go.Spot.Default;\r\n    // vertical line -- comparing x-values\r\n    otherObjs.each((other) => {\r\n      if (other === part) return; // ignore itself\r\n\r\n      const otherBounds = other.locationObject.getDocumentBounds();\r\n      const q0 = otherBounds.x;\r\n      const q1 = otherBounds.x + otherBounds.width / 2;\r\n      const q2 = otherBounds.x + otherBounds.width;\r\n\r\n      // compare center with center of OTHER part\r\n      if (Math.abs(p1 - q1) < bestDiff) {\r\n        bestDiff = Math.abs(p1 - q1);\r\n        bestObj = other;\r\n        bestSpot = go.Spot.Center;\r\n        bestOtherSpot = go.Spot.Center;\r\n      }\r\n      // compare left side with left and right sides of OTHER part\r\n      if (Math.abs(p0 - q0) < bestDiff) {\r\n        bestDiff = Math.abs(p0 - q0);\r\n        bestObj = other;\r\n        bestSpot = go.Spot.Left;\r\n        bestOtherSpot = go.Spot.Left;\r\n      } else if (Math.abs(p0 - q2) < bestDiff) {\r\n        bestDiff = Math.abs(p0 - q2);\r\n        bestObj = other;\r\n        bestSpot = go.Spot.Left;\r\n        bestOtherSpot = go.Spot.Right;\r\n      }\r\n      // compare right side with left and right sides of OTHER part\r\n      if (Math.abs(p2 - q0) < bestDiff) {\r\n        bestDiff = Math.abs(p2 - q0);\r\n        bestObj = other;\r\n        bestSpot = go.Spot.Right;\r\n        bestOtherSpot = go.Spot.Left;\r\n      } else if (Math.abs(p2 - q2) < bestDiff) {\r\n        bestDiff = Math.abs(p2 - q2);\r\n        bestObj = other;\r\n        bestSpot = go.Spot.Right;\r\n        bestOtherSpot = go.Spot.Right;\r\n      }\r\n    });\r\n\r\n    if (bestObj !== null) {\r\n      const offsetX = objBounds.x - part.actualBounds.x;\r\n      const offsetY = objBounds.y - part.actualBounds.y;\r\n      const bestBounds = bestObj.locationObject.getDocumentBounds();\r\n      // line extends from y0 to y2\r\n      const y0 = Math.min(objBounds.y, bestBounds.y) - 10;\r\n      const y2 = Math.max(objBounds.y + objBounds.height, bestBounds.y + bestBounds.height) + 10;\r\n      // find bestObj's desired X\r\n      const bestPoint = new go.Point().setRectSpot(bestBounds, bestOtherSpot);\r\n      if (bestSpot === go.Spot.Center) {\r\n        if (snap) {\r\n          // call Part.move in order to automatically move member Parts of Groups\r\n          part.move(new go.Point(bestPoint.x - objBounds.width / 2 - offsetX, objBounds.y - offsetY));\r\n          this.invalidateLinks(part);\r\n        }\r\n        if (guideline) {\r\n          this.guidelineVcenter.position = new go.Point(bestPoint.x, y0);\r\n          this.guidelineVcenter.elt(0).height = y2 - y0;\r\n          this.diagram.add(this.guidelineVcenter);\r\n        }\r\n      } else if (bestSpot === go.Spot.Left) {\r\n        if (snap) {\r\n          part.move(new go.Point(bestPoint.x - offsetX, objBounds.y - offsetY));\r\n          this.invalidateLinks(part);\r\n        }\r\n        if (guideline) {\r\n          this.guidelineVleft.position = new go.Point(bestPoint.x, y0);\r\n          this.guidelineVleft.elt(0).height = y2 - y0;\r\n          this.diagram.add(this.guidelineVleft);\r\n        }\r\n      } else if (bestSpot === go.Spot.Right) {\r\n        if (snap) {\r\n          part.move(new go.Point(bestPoint.x - objBounds.width - offsetX, objBounds.y - offsetY));\r\n          this.invalidateLinks(part);\r\n        }\r\n        if (guideline) {\r\n          this.guidelineVright.position = new go.Point(bestPoint.x, y0);\r\n          this.guidelineVright.elt(0).height = y2 - y0;\r\n          this.diagram.add(this.guidelineVright);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}